{"version":3,"file":"stimulus.min.js","sources":["../src/core/event_listener.ts","../src/core/dispatcher.ts","../src/core/action_descriptor.ts","../src/core/string_helpers.ts","../src/core/action.ts","../src/core/binding.ts","../src/mutation-observers/element_observer.ts","../src/mutation-observers/attribute_observer.ts","../src/mutation-observers/string_map_observer.ts","../src/multimap/set_operations.ts","../src/multimap/multimap.ts","../src/multimap/indexed_multimap.ts","../src/mutation-observers/token_list_observer.ts","../src/mutation-observers/value_list_observer.ts","../src/core/binding_observer.ts","../src/core/value_observer.ts","../src/core/target_observer.ts","../src/core/context.ts","../src/core/inheritable_statics.ts","../src/core/blessing.ts","../src/core/module.ts","../src/core/definition.ts","../src/core/class_map.ts","../src/core/data_map.ts","../src/core/guide.ts","../src/core/selectors.ts","../src/core/target_set.ts","../src/core/scope.ts","../src/core/scope_observer.ts","../src/core/router.ts","../src/core/schema.ts","../src/core/application.ts","../src/core/value_properties.ts","../src/core/controller.ts","../src/core/class_properties.ts","../src/core/target_properties.ts"],"sourcesContent":["import { Binding } from \"./binding\"\n\nexport class EventListener implements EventListenerObject {\n  readonly eventTarget: EventTarget\n  readonly eventName: string\n  readonly eventOptions: AddEventListenerOptions\n  private unorderedBindings: Set<Binding>\n\n  constructor(eventTarget: EventTarget, eventName: string, eventOptions: AddEventListenerOptions) {\n    this.eventTarget = eventTarget\n    this.eventName = eventName\n    this.eventOptions = eventOptions\n    this.unorderedBindings = new Set()\n  }\n\n  connect() {\n    this.eventTarget.addEventListener(this.eventName, this, this.eventOptions)\n  }\n\n  disconnect() {\n    this.eventTarget.removeEventListener(this.eventName, this, this.eventOptions)\n  }\n\n  // Binding observer delegate\n\n  bindingConnected(binding: Binding) {\n    this.unorderedBindings.add(binding)\n  }\n\n  bindingDisconnected(binding: Binding) {\n    this.unorderedBindings.delete(binding)\n  }\n\n  handleEvent(event: Event) {\n    // FIXME: Determine why TS won't recognize that the extended event has immediatePropagationStopped\n    const extendedEvent = extendEvent(event) as any\n    for (const binding of this.bindings) {\n      if (extendedEvent.immediatePropagationStopped) {\n        break\n      } else {\n        binding.handleEvent(extendedEvent)\n      }\n    }\n  }\n\n  hasBindings() {\n    return this.unorderedBindings.size > 0\n  }\n\n  get bindings(): Binding[] {\n    return Array.from(this.unorderedBindings).sort((left, right) => {\n      const leftIndex = left.index,\n        rightIndex = right.index\n      return leftIndex < rightIndex ? -1 : leftIndex > rightIndex ? 1 : 0\n    })\n  }\n}\n\nfunction extendEvent(event: Event) {\n  if (\"immediatePropagationStopped\" in event) {\n    return event\n  } else {\n    const { stopImmediatePropagation } = event\n    return Object.assign(event, {\n      immediatePropagationStopped: false,\n      stopImmediatePropagation() {\n        this.immediatePropagationStopped = true\n        stopImmediatePropagation.call(this)\n      },\n    })\n  }\n}\n","import { Application } from \"./application\"\nimport { Binding } from \"./binding\"\nimport { BindingObserverDelegate } from \"./binding_observer\"\nimport { EventListener } from \"./event_listener\"\n\nexport class Dispatcher implements BindingObserverDelegate {\n  readonly application: Application\n  private eventListenerMaps: Map<EventTarget, Map<string, EventListener>>\n  private started: boolean\n\n  constructor(application: Application) {\n    this.application = application\n    this.eventListenerMaps = new Map()\n    this.started = false\n  }\n\n  start() {\n    if (!this.started) {\n      this.started = true\n      this.eventListeners.forEach((eventListener) => eventListener.connect())\n    }\n  }\n\n  stop() {\n    if (this.started) {\n      this.started = false\n      this.eventListeners.forEach((eventListener) => eventListener.disconnect())\n    }\n  }\n\n  get eventListeners(): EventListener[] {\n    return Array.from(this.eventListenerMaps.values()).reduce(\n      (listeners, map) => listeners.concat(Array.from(map.values())),\n      [] as EventListener[]\n    )\n  }\n\n  // Binding observer delegate\n\n  bindingConnected(binding: Binding) {\n    this.fetchEventListenerForBinding(binding).bindingConnected(binding)\n  }\n\n  bindingDisconnected(binding: Binding, clearEventListeners: boolean = false) {\n    this.fetchEventListenerForBinding(binding).bindingDisconnected(binding)\n    if (clearEventListeners) this.clearEventListenersForBinding(binding)\n  }\n\n  // Error handling\n\n  handleError(error: Error, message: string, detail: object = {}) {\n    this.application.handleError(error, `Error ${message}`, detail)\n  }\n\n  private clearEventListenersForBinding(binding: Binding) {\n    const eventListener = this.fetchEventListenerForBinding(binding)\n    if (!eventListener.hasBindings()) {\n      eventListener.disconnect()\n      this.removeMappedEventListenerFor(binding)\n    }\n  }\n\n  private removeMappedEventListenerFor(binding: Binding) {\n    const { eventTarget, eventName, eventOptions } = binding\n    const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget)\n    const cacheKey = this.cacheKey(eventName, eventOptions)\n\n    eventListenerMap.delete(cacheKey)\n    if (eventListenerMap.size == 0) this.eventListenerMaps.delete(eventTarget)\n  }\n\n  private fetchEventListenerForBinding(binding: Binding): EventListener {\n    const { eventTarget, eventName, eventOptions } = binding\n    return this.fetchEventListener(eventTarget, eventName, eventOptions)\n  }\n\n  private fetchEventListener(\n    eventTarget: EventTarget,\n    eventName: string,\n    eventOptions: AddEventListenerOptions\n  ): EventListener {\n    const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget)\n    const cacheKey = this.cacheKey(eventName, eventOptions)\n    let eventListener = eventListenerMap.get(cacheKey)\n    if (!eventListener) {\n      eventListener = this.createEventListener(eventTarget, eventName, eventOptions)\n      eventListenerMap.set(cacheKey, eventListener)\n    }\n    return eventListener\n  }\n\n  private createEventListener(\n    eventTarget: EventTarget,\n    eventName: string,\n    eventOptions: AddEventListenerOptions\n  ): EventListener {\n    const eventListener = new EventListener(eventTarget, eventName, eventOptions)\n    if (this.started) {\n      eventListener.connect()\n    }\n    return eventListener\n  }\n\n  private fetchEventListenerMapForEventTarget(eventTarget: EventTarget): Map<string, EventListener> {\n    let eventListenerMap = this.eventListenerMaps.get(eventTarget)\n    if (!eventListenerMap) {\n      eventListenerMap = new Map()\n      this.eventListenerMaps.set(eventTarget, eventListenerMap)\n    }\n    return eventListenerMap\n  }\n\n  private cacheKey(eventName: string, eventOptions: any): string {\n    const parts = [eventName]\n    Object.keys(eventOptions)\n      .sort()\n      .forEach((key) => {\n        parts.push(`${eventOptions[key] ? \"\" : \"!\"}${key}`)\n      })\n    return parts.join(\":\")\n  }\n}\n","export interface ActionDescriptor {\n  eventTarget: EventTarget\n  eventOptions: AddEventListenerOptions\n  eventName: string\n  identifier: string\n  methodName: string\n}\n\nexport type ActionDescriptorFilters = Record<string, ActionDescriptorFilter>\nexport type ActionDescriptorFilter = (options: ActionDescriptorFilterOptions) => boolean\ntype ActionDescriptorFilterOptions = {\n  name: string\n  value: boolean\n  event: Event\n  element: Element\n}\n\nexport const defaultActionDescriptorFilters: ActionDescriptorFilters = {\n  stop({ event, value }) {\n    if (value) event.stopPropagation()\n\n    return true\n  },\n\n  prevent({ event, value }) {\n    if (value) event.preventDefault()\n\n    return true\n  },\n\n  self({ event, value, element }) {\n    if (value) {\n      return element === event.target\n    } else {\n      return true\n    }\n  },\n}\n\n// capture nos.:            12   23 4               43   1 5   56 7      768 9  98\nconst descriptorPattern = /^((.+?)(@(window|document))?->)?(.+?)(#([^:]+?))(:(.+))?$/\n\nexport function parseActionDescriptorString(descriptorString: string): Partial<ActionDescriptor> {\n  const source = descriptorString.trim()\n  const matches = source.match(descriptorPattern) || []\n  return {\n    eventTarget: parseEventTarget(matches[4]),\n    eventName: matches[2],\n    eventOptions: matches[9] ? parseEventOptions(matches[9]) : {},\n    identifier: matches[5],\n    methodName: matches[7],\n  }\n}\n\nfunction parseEventTarget(eventTargetName: string): EventTarget | undefined {\n  if (eventTargetName == \"window\") {\n    return window\n  } else if (eventTargetName == \"document\") {\n    return document\n  }\n}\n\nfunction parseEventOptions(eventOptions: string): AddEventListenerOptions {\n  return eventOptions\n    .split(\":\")\n    .reduce((options, token) => Object.assign(options, { [token.replace(/^!/, \"\")]: !/^!/.test(token) }), {})\n}\n\nexport function stringifyEventTarget(eventTarget: EventTarget) {\n  if (eventTarget == window) {\n    return \"window\"\n  } else if (eventTarget == document) {\n    return \"document\"\n  }\n}\n","export function camelize(value: string) {\n  return value.replace(/(?:[_-])([a-z0-9])/g, (_, char) => char.toUpperCase())\n}\n\nexport function capitalize(value: string) {\n  return value.charAt(0).toUpperCase() + value.slice(1)\n}\n\nexport function dasherize(value: string) {\n  return value.replace(/([A-Z])/g, (_, char) => `-${char.toLowerCase()}`)\n}\n\nexport function tokenize(value: string) {\n  return value.match(/[^\\s]+/g) || []\n}\n","import { ActionDescriptor, parseActionDescriptorString, stringifyEventTarget } from \"./action_descriptor\"\nimport { Token } from \"../mutation-observers\"\nimport { camelize } from \"./string_helpers\"\nexport class Action {\n  readonly element: Element\n  readonly index: number\n  readonly eventTarget: EventTarget\n  readonly eventName: string\n  readonly eventOptions: AddEventListenerOptions\n  readonly identifier: string\n  readonly methodName: string\n\n  static forToken(token: Token) {\n    return new this(token.element, token.index, parseActionDescriptorString(token.content))\n  }\n\n  constructor(element: Element, index: number, descriptor: Partial<ActionDescriptor>) {\n    this.element = element\n    this.index = index\n    this.eventTarget = descriptor.eventTarget || element\n    this.eventName = descriptor.eventName || getDefaultEventNameForElement(element) || error(\"missing event name\")\n    this.eventOptions = descriptor.eventOptions || {}\n    this.identifier = descriptor.identifier || error(\"missing identifier\")\n    this.methodName = descriptor.methodName || error(\"missing method name\")\n  }\n\n  toString() {\n    const eventNameSuffix = this.eventTargetName ? `@${this.eventTargetName}` : \"\"\n    return `${this.eventName}${eventNameSuffix}->${this.identifier}#${this.methodName}`\n  }\n\n  get params() {\n    const params: { [key: string]: any } = {}\n    const pattern = new RegExp(`^data-${this.identifier}-(.+)-param$`, \"i\")\n\n    for (const { name, value } of Array.from(this.element.attributes)) {\n      const match = name.match(pattern)\n      const key = match && match[1]\n      if (key) {\n        params[camelize(key)] = typecast(value)\n      }\n    }\n    return params\n  }\n\n  private get eventTargetName() {\n    return stringifyEventTarget(this.eventTarget)\n  }\n}\n\nconst defaultEventNames: { [tagName: string]: (element: Element) => string } = {\n  a: () => \"click\",\n  button: () => \"click\",\n  form: () => \"submit\",\n  details: () => \"toggle\",\n  input: (e) => (e.getAttribute(\"type\") == \"submit\" ? \"click\" : \"input\"),\n  select: () => \"change\",\n  textarea: () => \"input\",\n}\n\nexport function getDefaultEventNameForElement(element: Element): string | undefined {\n  const tagName = element.tagName.toLowerCase()\n  if (tagName in defaultEventNames) {\n    return defaultEventNames[tagName](element)\n  }\n}\n\nfunction error(message: string): never {\n  throw new Error(message)\n}\n\nfunction typecast(value: any): any {\n  try {\n    return JSON.parse(value)\n  } catch (o_O) {\n    return value\n  }\n}\n","import { Action } from \"./action\"\nimport { ActionEvent } from \"./action_event\"\nimport { Context } from \"./context\"\nimport { Controller } from \"./controller\"\nimport { Scope } from \"./scope\"\nexport class Binding {\n  readonly context: Context\n  readonly action: Action\n\n  constructor(context: Context, action: Action) {\n    this.context = context\n    this.action = action\n  }\n\n  get index(): number {\n    return this.action.index\n  }\n\n  get eventTarget(): EventTarget {\n    return this.action.eventTarget\n  }\n\n  get eventOptions(): AddEventListenerOptions {\n    return this.action.eventOptions\n  }\n\n  get identifier(): string {\n    return this.context.identifier\n  }\n\n  handleEvent(event: Event) {\n    if (this.willBeInvokedByEvent(event) && this.applyEventModifiers(event)) {\n      this.invokeWithEvent(event)\n    }\n  }\n\n  get eventName(): string {\n    return this.action.eventName\n  }\n\n  get method(): Function {\n    const method = (this.controller as any)[this.methodName]\n    if (typeof method == \"function\") {\n      return method\n    }\n    throw new Error(`Action \"${this.action}\" references undefined method \"${this.methodName}\"`)\n  }\n\n  private applyEventModifiers(event: Event): boolean {\n    const { element } = this.action\n    const { actionDescriptorFilters } = this.context.application\n\n    let passes = true\n\n    for (const [name, value] of Object.entries(this.eventOptions)) {\n      if (name in actionDescriptorFilters) {\n        const filter = actionDescriptorFilters[name]\n\n        passes = passes && filter({ name, value, event, element })\n      } else {\n        continue\n      }\n    }\n\n    return passes\n  }\n\n  private invokeWithEvent(event: Event) {\n    const { target, currentTarget } = event\n    try {\n      const { params } = this.action\n      const actionEvent: ActionEvent = Object.assign(event, { params })\n      this.method.call(this.controller, actionEvent)\n      this.context.logDebugActivity(this.methodName, { event, target, currentTarget, action: this.methodName })\n    } catch (error: any) {\n      const { identifier, controller, element, index } = this\n      const detail = { identifier, controller, element, index, event }\n      this.context.handleError(error, `invoking action \"${this.action}\"`, detail)\n    }\n  }\n\n  private willBeInvokedByEvent(event: Event): boolean {\n    const eventTarget = event.target\n    if (this.element === eventTarget) {\n      return true\n    } else if (eventTarget instanceof Element && this.element.contains(eventTarget)) {\n      return this.scope.containsElement(eventTarget)\n    } else {\n      return this.scope.containsElement(this.action.element)\n    }\n  }\n\n  private get controller(): Controller {\n    return this.context.controller\n  }\n\n  private get methodName(): string {\n    return this.action.methodName\n  }\n\n  private get element(): Element {\n    return this.scope.element\n  }\n\n  private get scope(): Scope {\n    return this.context.scope\n  }\n}\n","export interface ElementObserverDelegate {\n  matchElement(element: Element): boolean\n  matchElementsInTree(tree: Element): Element[]\n\n  elementMatched?(element: Element): void\n  elementUnmatched?(element: Element): void\n  elementAttributeChanged?(element: Element, attributeName: string): void\n}\n\nexport class ElementObserver {\n  element: Element\n  started: boolean\n  private delegate: ElementObserverDelegate\n\n  private elements: Set<Element>\n  private mutationObserver: MutationObserver\n  private mutationObserverInit = { attributes: true, childList: true, subtree: true }\n\n  constructor(element: Element, delegate: ElementObserverDelegate) {\n    this.element = element\n    this.started = false\n    this.delegate = delegate\n\n    this.elements = new Set()\n    this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations))\n  }\n\n  start() {\n    if (!this.started) {\n      this.started = true\n      this.mutationObserver.observe(this.element, this.mutationObserverInit)\n      this.refresh()\n    }\n  }\n\n  pause(callback: () => void) {\n    if (this.started) {\n      this.mutationObserver.disconnect()\n      this.started = false\n    }\n\n    callback()\n\n    if (!this.started) {\n      this.mutationObserver.observe(this.element, this.mutationObserverInit)\n      this.started = true\n    }\n  }\n\n  stop() {\n    if (this.started) {\n      this.mutationObserver.takeRecords()\n      this.mutationObserver.disconnect()\n      this.started = false\n    }\n  }\n\n  refresh() {\n    if (this.started) {\n      const matches = new Set(this.matchElementsInTree())\n\n      for (const element of Array.from(this.elements)) {\n        if (!matches.has(element)) {\n          this.removeElement(element)\n        }\n      }\n\n      for (const element of Array.from(matches)) {\n        this.addElement(element)\n      }\n    }\n  }\n\n  // Mutation record processing\n\n  private processMutations(mutations: MutationRecord[]) {\n    if (this.started) {\n      for (const mutation of mutations) {\n        this.processMutation(mutation)\n      }\n    }\n  }\n\n  private processMutation(mutation: MutationRecord) {\n    if (mutation.type == \"attributes\") {\n      this.processAttributeChange(mutation.target, mutation.attributeName!)\n    } else if (mutation.type == \"childList\") {\n      this.processRemovedNodes(mutation.removedNodes)\n      this.processAddedNodes(mutation.addedNodes)\n    }\n  }\n\n  private processAttributeChange(node: Node, attributeName: string) {\n    const element = node as Element\n    if (this.elements.has(element)) {\n      if (this.delegate.elementAttributeChanged && this.matchElement(element)) {\n        this.delegate.elementAttributeChanged(element, attributeName)\n      } else {\n        this.removeElement(element)\n      }\n    } else if (this.matchElement(element)) {\n      this.addElement(element)\n    }\n  }\n\n  private processRemovedNodes(nodes: NodeList) {\n    for (const node of Array.from(nodes)) {\n      const element = this.elementFromNode(node)\n      if (element) {\n        this.processTree(element, this.removeElement)\n      }\n    }\n  }\n\n  private processAddedNodes(nodes: NodeList) {\n    for (const node of Array.from(nodes)) {\n      const element = this.elementFromNode(node)\n      if (element && this.elementIsActive(element)) {\n        this.processTree(element, this.addElement)\n      }\n    }\n  }\n\n  // Element matching\n\n  private matchElement(element: Element): boolean {\n    return this.delegate.matchElement(element)\n  }\n\n  private matchElementsInTree(tree: Element = this.element): Element[] {\n    return this.delegate.matchElementsInTree(tree)\n  }\n\n  private processTree(tree: Element, processor: (element: Element) => void) {\n    for (const element of this.matchElementsInTree(tree)) {\n      processor.call(this, element)\n    }\n  }\n\n  private elementFromNode(node: Node): Element | undefined {\n    if (node.nodeType == Node.ELEMENT_NODE) {\n      return node as Element\n    }\n  }\n\n  private elementIsActive(element: Element): boolean {\n    if (element.isConnected != this.element.isConnected) {\n      return false\n    } else {\n      return this.element.contains(element)\n    }\n  }\n\n  // Element tracking\n\n  private addElement(element: Element) {\n    if (!this.elements.has(element)) {\n      if (this.elementIsActive(element)) {\n        this.elements.add(element)\n        if (this.delegate.elementMatched) {\n          this.delegate.elementMatched(element)\n        }\n      }\n    }\n  }\n\n  private removeElement(element: Element) {\n    if (this.elements.has(element)) {\n      this.elements.delete(element)\n      if (this.delegate.elementUnmatched) {\n        this.delegate.elementUnmatched(element)\n      }\n    }\n  }\n}\n","import { ElementObserver, ElementObserverDelegate } from \"./element_observer\"\n\nexport interface AttributeObserverDelegate {\n  elementMatchedAttribute?(element: Element, attributeName: string): void\n  elementAttributeValueChanged?(element: Element, attributeName: string): void\n  elementUnmatchedAttribute?(element: Element, attributeName: string): void\n}\n\nexport class AttributeObserver implements ElementObserverDelegate {\n  attributeName: string\n  private delegate: AttributeObserverDelegate\n\n  private elementObserver: ElementObserver\n\n  constructor(element: Element, attributeName: string, delegate: AttributeObserverDelegate) {\n    this.attributeName = attributeName\n    this.delegate = delegate\n\n    this.elementObserver = new ElementObserver(element, this)\n  }\n\n  get element(): Element {\n    return this.elementObserver.element\n  }\n\n  get selector(): string {\n    return `[${this.attributeName}]`\n  }\n\n  start() {\n    this.elementObserver.start()\n  }\n\n  pause(callback: () => void) {\n    this.elementObserver.pause(callback)\n  }\n\n  stop() {\n    this.elementObserver.stop()\n  }\n\n  refresh() {\n    this.elementObserver.refresh()\n  }\n\n  get started(): boolean {\n    return this.elementObserver.started\n  }\n\n  // Element observer delegate\n\n  matchElement(element: Element): boolean {\n    return element.hasAttribute(this.attributeName)\n  }\n\n  matchElementsInTree(tree: Element): Element[] {\n    const match = this.matchElement(tree) ? [tree] : []\n    const matches = Array.from(tree.querySelectorAll(this.selector))\n    return match.concat(matches)\n  }\n\n  elementMatched(element: Element) {\n    if (this.delegate.elementMatchedAttribute) {\n      this.delegate.elementMatchedAttribute(element, this.attributeName)\n    }\n  }\n\n  elementUnmatched(element: Element) {\n    if (this.delegate.elementUnmatchedAttribute) {\n      this.delegate.elementUnmatchedAttribute(element, this.attributeName)\n    }\n  }\n\n  elementAttributeChanged(element: Element, attributeName: string) {\n    if (this.delegate.elementAttributeValueChanged && this.attributeName == attributeName) {\n      this.delegate.elementAttributeValueChanged(element, attributeName)\n    }\n  }\n}\n","export interface StringMapObserverDelegate {\n  getStringMapKeyForAttribute(attributeName: string): string | undefined\n  stringMapKeyAdded?(key: string, attributeName: string): void\n  stringMapValueChanged?(value: string | null, key: string, oldValue: string | null): void\n  stringMapKeyRemoved?(key: string, attributeName: string, oldValue: string | null): void\n}\n\nexport class StringMapObserver {\n  readonly element: Element\n  readonly delegate: StringMapObserverDelegate\n  private started: boolean\n  private stringMap: Map<string, string>\n  private mutationObserver: MutationObserver\n\n  constructor(element: Element, delegate: StringMapObserverDelegate) {\n    this.element = element\n    this.delegate = delegate\n    this.started = false\n    this.stringMap = new Map()\n    this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations))\n  }\n\n  start() {\n    if (!this.started) {\n      this.started = true\n      this.mutationObserver.observe(this.element, { attributes: true, attributeOldValue: true })\n      this.refresh()\n    }\n  }\n\n  stop() {\n    if (this.started) {\n      this.mutationObserver.takeRecords()\n      this.mutationObserver.disconnect()\n      this.started = false\n    }\n  }\n\n  refresh() {\n    if (this.started) {\n      for (const attributeName of this.knownAttributeNames) {\n        this.refreshAttribute(attributeName, null)\n      }\n    }\n  }\n\n  // Mutation record processing\n\n  private processMutations(mutations: MutationRecord[]) {\n    if (this.started) {\n      for (const mutation of mutations) {\n        this.processMutation(mutation)\n      }\n    }\n  }\n\n  private processMutation(mutation: MutationRecord) {\n    const attributeName = mutation.attributeName\n    if (attributeName) {\n      this.refreshAttribute(attributeName, mutation.oldValue)\n    }\n  }\n\n  // State tracking\n\n  private refreshAttribute(attributeName: string, oldValue: string | null) {\n    const key = this.delegate.getStringMapKeyForAttribute(attributeName)\n    if (key != null) {\n      if (!this.stringMap.has(attributeName)) {\n        this.stringMapKeyAdded(key, attributeName)\n      }\n\n      const value = this.element.getAttribute(attributeName)\n      if (this.stringMap.get(attributeName) != value) {\n        this.stringMapValueChanged(value, key, oldValue)\n      }\n\n      if (value == null) {\n        const oldValue = this.stringMap.get(attributeName)\n        this.stringMap.delete(attributeName)\n        if (oldValue) this.stringMapKeyRemoved(key, attributeName, oldValue)\n      } else {\n        this.stringMap.set(attributeName, value)\n      }\n    }\n  }\n\n  private stringMapKeyAdded(key: string, attributeName: string) {\n    if (this.delegate.stringMapKeyAdded) {\n      this.delegate.stringMapKeyAdded(key, attributeName)\n    }\n  }\n\n  private stringMapValueChanged(value: string | null, key: string, oldValue: string | null) {\n    if (this.delegate.stringMapValueChanged) {\n      this.delegate.stringMapValueChanged(value, key, oldValue)\n    }\n  }\n\n  private stringMapKeyRemoved(key: string, attributeName: string, oldValue: string | null) {\n    if (this.delegate.stringMapKeyRemoved) {\n      this.delegate.stringMapKeyRemoved(key, attributeName, oldValue)\n    }\n  }\n\n  private get knownAttributeNames() {\n    return Array.from(new Set(this.currentAttributeNames.concat(this.recordedAttributeNames)))\n  }\n\n  private get currentAttributeNames() {\n    return Array.from(this.element.attributes).map((attribute) => attribute.name)\n  }\n\n  private get recordedAttributeNames() {\n    return Array.from(this.stringMap.keys())\n  }\n}\n","export function add<K, V>(map: Map<K, Set<V>>, key: K, value: V) {\n  fetch(map, key).add(value)\n}\n\nexport function del<K, V>(map: Map<K, Set<V>>, key: K, value: V) {\n  fetch(map, key).delete(value)\n  prune(map, key)\n}\n\nexport function fetch<K, V>(map: Map<K, Set<V>>, key: K): Set<V> {\n  let values = map.get(key)\n  if (!values) {\n    values = new Set()\n    map.set(key, values)\n  }\n  return values\n}\n\nexport function prune<K, V>(map: Map<K, Set<V>>, key: K) {\n  const values = map.get(key)\n  if (values != null && values.size == 0) {\n    map.delete(key)\n  }\n}\n","import { add, del } from \"./set_operations\"\n\nexport class Multimap<K, V> {\n  private valuesByKey: Map<K, Set<V>>\n\n  constructor() {\n    this.valuesByKey = new Map<K, Set<V>>()\n  }\n\n  get keys() {\n    return Array.from(this.valuesByKey.keys())\n  }\n\n  get values(): V[] {\n    const sets = Array.from(this.valuesByKey.values())\n    return sets.reduce((values, set) => values.concat(Array.from(set)), <V[]>[])\n  }\n\n  get size(): number {\n    const sets = Array.from(this.valuesByKey.values())\n    return sets.reduce((size, set) => size + set.size, 0)\n  }\n\n  add(key: K, value: V) {\n    add(this.valuesByKey, key, value)\n  }\n\n  delete(key: K, value: V) {\n    del(this.valuesByKey, key, value)\n  }\n\n  has(key: K, value: V): boolean {\n    const values = this.valuesByKey.get(key)\n    return values != null && values.has(value)\n  }\n\n  hasKey(key: K): boolean {\n    return this.valuesByKey.has(key)\n  }\n\n  hasValue(value: V): boolean {\n    const sets = Array.from(this.valuesByKey.values())\n    return sets.some((set) => set.has(value))\n  }\n\n  getValuesForKey(key: K): V[] {\n    const values = this.valuesByKey.get(key)\n    return values ? Array.from(values) : []\n  }\n\n  getKeysForValue(value: V): K[] {\n    return Array.from(this.valuesByKey)\n      .filter(([_key, values]) => values.has(value))\n      .map(([key, _values]) => key)\n  }\n}\n","import { Multimap } from \"./multimap\"\nimport { add, del } from \"./set_operations\"\n\nexport class IndexedMultimap<K, V> extends Multimap<K, V> {\n  private keysByValue: Map<V, Set<K>>\n\n  constructor() {\n    super()\n    this.keysByValue = new Map()\n  }\n\n  get values(): V[] {\n    return Array.from(this.keysByValue.keys())\n  }\n\n  add(key: K, value: V) {\n    super.add(key, value)\n    add(this.keysByValue, value, key)\n  }\n\n  delete(key: K, value: V) {\n    super.delete(key, value)\n    del(this.keysByValue, value, key)\n  }\n\n  hasValue(value: V): boolean {\n    return this.keysByValue.has(value)\n  }\n\n  getKeysForValue(value: V): K[] {\n    const set = this.keysByValue.get(value)\n    return set ? Array.from(set) : []\n  }\n}\n","import { AttributeObserver, AttributeObserverDelegate } from \"./attribute_observer\"\nimport { Multimap } from \"../multimap\"\n\nexport interface Token {\n  element: Element\n  attributeName: string\n  index: number\n  content: string\n}\n\nexport interface TokenListObserverDelegate {\n  tokenMatched(token: Token): void\n  tokenUnmatched(token: Token): void\n}\n\nexport class TokenListObserver implements AttributeObserverDelegate {\n  private attributeObserver: AttributeObserver\n  private delegate: TokenListObserverDelegate\n  private tokensByElement: Multimap<Element, Token>\n\n  constructor(element: Element, attributeName: string, delegate: TokenListObserverDelegate) {\n    this.attributeObserver = new AttributeObserver(element, attributeName, this)\n    this.delegate = delegate\n    this.tokensByElement = new Multimap()\n  }\n\n  get started(): boolean {\n    return this.attributeObserver.started\n  }\n\n  start() {\n    this.attributeObserver.start()\n  }\n\n  pause(callback: () => void) {\n    this.attributeObserver.pause(callback)\n  }\n\n  stop() {\n    this.attributeObserver.stop()\n  }\n\n  refresh() {\n    this.attributeObserver.refresh()\n  }\n\n  get element(): Element {\n    return this.attributeObserver.element\n  }\n\n  get attributeName(): string {\n    return this.attributeObserver.attributeName\n  }\n\n  // Attribute observer delegate\n\n  elementMatchedAttribute(element: Element) {\n    this.tokensMatched(this.readTokensForElement(element))\n  }\n\n  elementAttributeValueChanged(element: Element) {\n    const [unmatchedTokens, matchedTokens] = this.refreshTokensForElement(element)\n    this.tokensUnmatched(unmatchedTokens)\n    this.tokensMatched(matchedTokens)\n  }\n\n  elementUnmatchedAttribute(element: Element) {\n    this.tokensUnmatched(this.tokensByElement.getValuesForKey(element))\n  }\n\n  private tokensMatched(tokens: Token[]) {\n    tokens.forEach((token) => this.tokenMatched(token))\n  }\n\n  private tokensUnmatched(tokens: Token[]) {\n    tokens.forEach((token) => this.tokenUnmatched(token))\n  }\n\n  private tokenMatched(token: Token) {\n    this.delegate.tokenMatched(token)\n    this.tokensByElement.add(token.element, token)\n  }\n\n  private tokenUnmatched(token: Token) {\n    this.delegate.tokenUnmatched(token)\n    this.tokensByElement.delete(token.element, token)\n  }\n\n  private refreshTokensForElement(element: Element): [Token[], Token[]] {\n    const previousTokens = this.tokensByElement.getValuesForKey(element)\n    const currentTokens = this.readTokensForElement(element)\n    const firstDifferingIndex = zip(previousTokens, currentTokens).findIndex(\n      ([previousToken, currentToken]) => !tokensAreEqual(previousToken, currentToken)\n    )\n\n    if (firstDifferingIndex == -1) {\n      return [[], []]\n    } else {\n      return [previousTokens.slice(firstDifferingIndex), currentTokens.slice(firstDifferingIndex)]\n    }\n  }\n\n  private readTokensForElement(element: Element): Token[] {\n    const attributeName = this.attributeName\n    const tokenString = element.getAttribute(attributeName) || \"\"\n    return parseTokenString(tokenString, element, attributeName)\n  }\n}\n\nfunction parseTokenString(tokenString: string, element: Element, attributeName: string): Token[] {\n  return tokenString\n    .trim()\n    .split(/\\s+/)\n    .filter((content) => content.length)\n    .map((content, index) => ({ element, attributeName, content, index }))\n}\n\nfunction zip<L, R>(left: L[], right: R[]): [L | undefined, R | undefined][] {\n  const length = Math.max(left.length, right.length)\n  return Array.from({ length }, (_, index) => [left[index], right[index]] as [L, R])\n}\n\nfunction tokensAreEqual(left?: Token, right?: Token) {\n  return left && right && left.index == right.index && left.content == right.content\n}\n","import { Token, TokenListObserver, TokenListObserverDelegate } from \"./token_list_observer\"\n\nexport interface ValueListObserverDelegate<T> {\n  parseValueForToken(token: Token): T | undefined\n  elementMatchedValue(element: Element, value: T): void\n  elementUnmatchedValue(element: Element, value: T): void\n}\n\ninterface ParseResult<T> {\n  value?: T\n  error?: Error\n}\n\nexport class ValueListObserver<T> implements TokenListObserverDelegate {\n  private tokenListObserver: TokenListObserver\n  private delegate: ValueListObserverDelegate<T>\n  private parseResultsByToken: WeakMap<Token, ParseResult<T>>\n  private valuesByTokenByElement: WeakMap<Element, Map<Token, T>>\n\n  constructor(element: Element, attributeName: string, delegate: ValueListObserverDelegate<T>) {\n    this.tokenListObserver = new TokenListObserver(element, attributeName, this)\n    this.delegate = delegate\n    this.parseResultsByToken = new WeakMap()\n    this.valuesByTokenByElement = new WeakMap()\n  }\n\n  get started(): boolean {\n    return this.tokenListObserver.started\n  }\n\n  start() {\n    this.tokenListObserver.start()\n  }\n\n  stop() {\n    this.tokenListObserver.stop()\n  }\n\n  refresh() {\n    this.tokenListObserver.refresh()\n  }\n\n  get element(): Element {\n    return this.tokenListObserver.element\n  }\n\n  get attributeName(): string {\n    return this.tokenListObserver.attributeName\n  }\n\n  tokenMatched(token: Token) {\n    const { element } = token\n    const { value } = this.fetchParseResultForToken(token)\n    if (value) {\n      this.fetchValuesByTokenForElement(element).set(token, value)\n      this.delegate.elementMatchedValue(element, value)\n    }\n  }\n\n  tokenUnmatched(token: Token) {\n    const { element } = token\n    const { value } = this.fetchParseResultForToken(token)\n    if (value) {\n      this.fetchValuesByTokenForElement(element).delete(token)\n      this.delegate.elementUnmatchedValue(element, value)\n    }\n  }\n\n  private fetchParseResultForToken(token: Token) {\n    let parseResult = this.parseResultsByToken.get(token)\n    if (!parseResult) {\n      parseResult = this.parseToken(token)\n      this.parseResultsByToken.set(token, parseResult)\n    }\n    return parseResult\n  }\n\n  private fetchValuesByTokenForElement(element: Element) {\n    let valuesByToken = this.valuesByTokenByElement.get(element)\n    if (!valuesByToken) {\n      valuesByToken = new Map()\n      this.valuesByTokenByElement.set(element, valuesByToken)\n    }\n    return valuesByToken\n  }\n\n  private parseToken(token: Token): ParseResult<T> {\n    try {\n      const value = this.delegate.parseValueForToken(token)\n      return { value }\n    } catch (error: any) {\n      return { error }\n    }\n  }\n}\n","import { Action } from \"./action\"\nimport { Binding } from \"./binding\"\nimport { Context } from \"./context\"\nimport { ErrorHandler } from \"./error_handler\"\nimport { Schema } from \"./schema\"\nimport { Token, ValueListObserver, ValueListObserverDelegate } from \"../mutation-observers\"\n\nexport interface BindingObserverDelegate extends ErrorHandler {\n  bindingConnected(binding: Binding): void\n  bindingDisconnected(binding: Binding, clearEventListeners?: boolean): void\n}\n\nexport class BindingObserver implements ValueListObserverDelegate<Action> {\n  readonly context: Context\n  private delegate: BindingObserverDelegate\n  private valueListObserver?: ValueListObserver<Action>\n  private bindingsByAction: Map<Action, Binding>\n\n  constructor(context: Context, delegate: BindingObserverDelegate) {\n    this.context = context\n    this.delegate = delegate\n    this.bindingsByAction = new Map()\n  }\n\n  start() {\n    if (!this.valueListObserver) {\n      this.valueListObserver = new ValueListObserver(this.element, this.actionAttribute, this)\n      this.valueListObserver.start()\n    }\n  }\n\n  stop() {\n    if (this.valueListObserver) {\n      this.valueListObserver.stop()\n      delete this.valueListObserver\n      this.disconnectAllActions()\n    }\n  }\n\n  get element() {\n    return this.context.element\n  }\n\n  get identifier() {\n    return this.context.identifier\n  }\n\n  get actionAttribute() {\n    return this.schema.actionAttribute\n  }\n\n  get schema(): Schema {\n    return this.context.schema\n  }\n\n  get bindings(): Binding[] {\n    return Array.from(this.bindingsByAction.values())\n  }\n\n  private connectAction(action: Action) {\n    const binding = new Binding(this.context, action)\n    this.bindingsByAction.set(action, binding)\n    this.delegate.bindingConnected(binding)\n  }\n\n  private disconnectAction(action: Action) {\n    const binding = this.bindingsByAction.get(action)\n    if (binding) {\n      this.bindingsByAction.delete(action)\n      this.delegate.bindingDisconnected(binding)\n    }\n  }\n\n  private disconnectAllActions() {\n    this.bindings.forEach((binding) => this.delegate.bindingDisconnected(binding, true))\n    this.bindingsByAction.clear()\n  }\n\n  // Value observer delegate\n\n  parseValueForToken(token: Token): Action | undefined {\n    const action = Action.forToken(token)\n    if (action.identifier == this.identifier) {\n      return action\n    }\n  }\n\n  elementMatchedValue(element: Element, action: Action) {\n    this.connectAction(action)\n  }\n\n  elementUnmatchedValue(element: Element, action: Action) {\n    this.disconnectAction(action)\n  }\n}\n","import { Context } from \"./context\"\nimport { StringMapObserver, StringMapObserverDelegate } from \"../mutation-observers\"\nimport { ValueDescriptor } from \"./value_properties\"\nimport { capitalize } from \"./string_helpers\"\n\nexport class ValueObserver implements StringMapObserverDelegate {\n  readonly context: Context\n  readonly receiver: any\n  private stringMapObserver: StringMapObserver\n  private valueDescriptorMap: { [attributeName: string]: ValueDescriptor }\n\n  constructor(context: Context, receiver: any) {\n    this.context = context\n    this.receiver = receiver\n    this.stringMapObserver = new StringMapObserver(this.element, this)\n    this.valueDescriptorMap = (this.controller as any).valueDescriptorMap\n  }\n\n  start() {\n    this.stringMapObserver.start()\n    this.invokeChangedCallbacksForDefaultValues()\n  }\n\n  stop() {\n    this.stringMapObserver.stop()\n  }\n\n  get element() {\n    return this.context.element\n  }\n\n  get controller() {\n    return this.context.controller\n  }\n\n  // String map observer delegate\n\n  getStringMapKeyForAttribute(attributeName: string) {\n    if (attributeName in this.valueDescriptorMap) {\n      return this.valueDescriptorMap[attributeName].name\n    }\n  }\n\n  stringMapKeyAdded(key: string, attributeName: string) {\n    const descriptor = this.valueDescriptorMap[attributeName]\n\n    if (!this.hasValue(key)) {\n      this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), descriptor.writer(descriptor.defaultValue))\n    }\n  }\n\n  stringMapValueChanged(value: string, name: string, oldValue: string) {\n    const descriptor = this.valueDescriptorNameMap[name]\n\n    if (value === null) return\n\n    if (oldValue === null) {\n      oldValue = descriptor.writer(descriptor.defaultValue)\n    }\n\n    this.invokeChangedCallback(name, value, oldValue)\n  }\n\n  stringMapKeyRemoved(key: string, attributeName: string, oldValue: string) {\n    const descriptor = this.valueDescriptorNameMap[key]\n\n    if (this.hasValue(key)) {\n      this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), oldValue)\n    } else {\n      this.invokeChangedCallback(key, descriptor.writer(descriptor.defaultValue), oldValue)\n    }\n  }\n\n  private invokeChangedCallbacksForDefaultValues() {\n    for (const { key, name, defaultValue, writer } of this.valueDescriptors) {\n      if (defaultValue != undefined && !this.controller.data.has(key)) {\n        this.invokeChangedCallback(name, writer(defaultValue), undefined)\n      }\n    }\n  }\n\n  private invokeChangedCallback(name: string, rawValue: string, rawOldValue: string | undefined) {\n    const changedMethodName = `${name}Changed`\n    const changedMethod = this.receiver[changedMethodName]\n\n    if (typeof changedMethod == \"function\") {\n      const descriptor = this.valueDescriptorNameMap[name]\n\n      try {\n        const value = descriptor.reader(rawValue)\n        let oldValue = rawOldValue\n\n        if (rawOldValue) {\n          oldValue = descriptor.reader(rawOldValue)\n        }\n\n        changedMethod.call(this.receiver, value, oldValue)\n      } catch (error) {\n        if (error instanceof TypeError) {\n          error.message = `Stimulus Value \"${this.context.identifier}.${descriptor.name}\" - ${error.message}`\n        }\n\n        throw error\n      }\n    }\n  }\n\n  private get valueDescriptors() {\n    const { valueDescriptorMap } = this\n    return Object.keys(valueDescriptorMap).map((key) => valueDescriptorMap[key])\n  }\n\n  private get valueDescriptorNameMap() {\n    const descriptors: { [type: string]: ValueDescriptor } = {}\n\n    Object.keys(this.valueDescriptorMap).forEach((key) => {\n      const descriptor = this.valueDescriptorMap[key]\n      descriptors[descriptor.name] = descriptor\n    })\n\n    return descriptors\n  }\n\n  private hasValue(attributeName: string) {\n    const descriptor = this.valueDescriptorNameMap[attributeName]\n    const hasMethodName = `has${capitalize(descriptor.name)}`\n\n    return this.receiver[hasMethodName]\n  }\n}\n","import { Multimap } from \"../multimap\"\nimport { Token, TokenListObserver, TokenListObserverDelegate } from \"../mutation-observers\"\nimport { Context } from \"./context\"\n\nexport interface TargetObserverDelegate {\n  targetConnected(element: Element, name: string): void\n  targetDisconnected(element: Element, name: string): void\n}\n\nexport class TargetObserver implements TokenListObserverDelegate {\n  readonly context: Context\n  readonly delegate: TargetObserverDelegate\n  readonly targetsByName: Multimap<string, Element>\n  private tokenListObserver?: TokenListObserver\n\n  constructor(context: Context, delegate: TargetObserverDelegate) {\n    this.context = context\n    this.delegate = delegate\n    this.targetsByName = new Multimap()\n  }\n\n  start() {\n    if (!this.tokenListObserver) {\n      this.tokenListObserver = new TokenListObserver(this.element, this.attributeName, this)\n      this.tokenListObserver.start()\n    }\n  }\n\n  stop() {\n    if (this.tokenListObserver) {\n      this.disconnectAllTargets()\n      this.tokenListObserver.stop()\n      delete this.tokenListObserver\n    }\n  }\n\n  // Token list observer delegate\n\n  tokenMatched({ element, content: name }: Token) {\n    if (this.scope.containsElement(element)) {\n      this.connectTarget(element, name)\n    }\n  }\n\n  tokenUnmatched({ element, content: name }: Token) {\n    this.disconnectTarget(element, name)\n  }\n\n  // Target management\n\n  connectTarget(element: Element, name: string) {\n    if (!this.targetsByName.has(name, element)) {\n      this.targetsByName.add(name, element)\n      this.tokenListObserver?.pause(() => this.delegate.targetConnected(element, name))\n    }\n  }\n\n  disconnectTarget(element: Element, name: string) {\n    if (this.targetsByName.has(name, element)) {\n      this.targetsByName.delete(name, element)\n      this.tokenListObserver?.pause(() => this.delegate.targetDisconnected(element, name))\n    }\n  }\n\n  disconnectAllTargets() {\n    for (const name of this.targetsByName.keys) {\n      for (const element of this.targetsByName.getValuesForKey(name)) {\n        this.disconnectTarget(element, name)\n      }\n    }\n  }\n\n  // Private\n\n  private get attributeName() {\n    return `data-${this.context.identifier}-target`\n  }\n\n  private get element() {\n    return this.context.element\n  }\n\n  private get scope() {\n    return this.context.scope\n  }\n}\n","import { Application } from \"./application\"\nimport { BindingObserver } from \"./binding_observer\"\nimport { Controller } from \"./controller\"\nimport { Dispatcher } from \"./dispatcher\"\nimport { ErrorHandler } from \"./error_handler\"\nimport { Module } from \"./module\"\nimport { Schema } from \"./schema\"\nimport { Scope } from \"./scope\"\nimport { ValueObserver } from \"./value_observer\"\nimport { TargetObserver, TargetObserverDelegate } from \"./target_observer\"\n\nexport class Context implements ErrorHandler, TargetObserverDelegate {\n  readonly module: Module\n  readonly scope: Scope\n  readonly controller: Controller\n  private bindingObserver: BindingObserver\n  private valueObserver: ValueObserver\n  private targetObserver: TargetObserver\n\n  constructor(module: Module, scope: Scope) {\n    this.module = module\n    this.scope = scope\n    this.controller = new module.controllerConstructor(this)\n    this.bindingObserver = new BindingObserver(this, this.dispatcher)\n    this.valueObserver = new ValueObserver(this, this.controller)\n    this.targetObserver = new TargetObserver(this, this)\n\n    try {\n      this.controller.initialize()\n      this.logDebugActivity(\"initialize\")\n    } catch (error: any) {\n      this.handleError(error, \"initializing controller\")\n    }\n  }\n\n  connect() {\n    this.bindingObserver.start()\n    this.valueObserver.start()\n    this.targetObserver.start()\n\n    try {\n      this.controller.connect()\n      this.logDebugActivity(\"connect\")\n    } catch (error: any) {\n      this.handleError(error, \"connecting controller\")\n    }\n  }\n\n  disconnect() {\n    try {\n      this.controller.disconnect()\n      this.logDebugActivity(\"disconnect\")\n    } catch (error: any) {\n      this.handleError(error, \"disconnecting controller\")\n    }\n\n    this.targetObserver.stop()\n    this.valueObserver.stop()\n    this.bindingObserver.stop()\n  }\n\n  get application(): Application {\n    return this.module.application\n  }\n\n  get identifier(): string {\n    return this.module.identifier\n  }\n\n  get schema(): Schema {\n    return this.application.schema\n  }\n\n  get dispatcher(): Dispatcher {\n    return this.application.dispatcher\n  }\n\n  get element(): Element {\n    return this.scope.element\n  }\n\n  get parentElement(): Element | null {\n    return this.element.parentElement\n  }\n\n  // Error handling\n\n  handleError(error: Error, message: string, detail: object = {}) {\n    const { identifier, controller, element } = this\n    detail = Object.assign({ identifier, controller, element }, detail)\n    this.application.handleError(error, `Error ${message}`, detail)\n  }\n\n  // Debug logging\n\n  logDebugActivity = (functionName: string, detail: object = {}): void => {\n    const { identifier, controller, element } = this\n    detail = Object.assign({ identifier, controller, element }, detail)\n    this.application.logDebugActivity(this.identifier, functionName, detail)\n  }\n\n  // Target observer delegate\n\n  targetConnected(element: Element, name: string) {\n    this.invokeControllerMethod(`${name}TargetConnected`, element)\n  }\n\n  targetDisconnected(element: Element, name: string) {\n    this.invokeControllerMethod(`${name}TargetDisconnected`, element)\n  }\n\n  // Private\n\n  invokeControllerMethod(methodName: string, ...args: any[]) {\n    const controller: any = this.controller\n    if (typeof controller[methodName] == \"function\") {\n      controller[methodName](...args)\n    }\n  }\n}\n","import { Constructor } from \"./constructor\"\n\nexport function readInheritableStaticArrayValues<T, U = string>(constructor: Constructor<T>, propertyName: string) {\n  const ancestors = getAncestorsForConstructor(constructor)\n  return Array.from(\n    ancestors.reduce((values, constructor) => {\n      getOwnStaticArrayValues(constructor, propertyName).forEach((name) => values.add(name))\n      return values\n    }, new Set() as Set<U>)\n  )\n}\n\nexport function readInheritableStaticObjectPairs<T, U>(constructor: Constructor<T>, propertyName: string) {\n  const ancestors = getAncestorsForConstructor(constructor)\n  return ancestors.reduce((pairs, constructor) => {\n    pairs.push(...(getOwnStaticObjectPairs(constructor, propertyName) as any))\n    return pairs\n  }, [] as [string, U][])\n}\n\nfunction getAncestorsForConstructor<T>(constructor: Constructor<T>) {\n  const ancestors: Constructor<any>[] = []\n  while (constructor) {\n    ancestors.push(constructor)\n    constructor = Object.getPrototypeOf(constructor)\n  }\n  return ancestors.reverse()\n}\n\nfunction getOwnStaticArrayValues<T>(constructor: Constructor<T>, propertyName: string) {\n  const definition = (constructor as any)[propertyName]\n  return Array.isArray(definition) ? definition : []\n}\n\nfunction getOwnStaticObjectPairs<T, U>(constructor: Constructor<T>, propertyName: string) {\n  const definition = (constructor as any)[propertyName]\n  return definition ? Object.keys(definition).map((key) => [key, definition[key]] as [string, U]) : []\n}\n","import { Constructor } from \"./constructor\"\nimport { readInheritableStaticArrayValues } from \"./inheritable_statics\"\n\nexport type Blessing<T> = (constructor: Constructor<T>) => PropertyDescriptorMap\n\nexport interface Blessable<T> extends Constructor<T> {\n  readonly blessings?: Blessing<T>[]\n}\n\nexport function bless<T>(constructor: Blessable<T>): Constructor<T> {\n  return shadow(constructor, getBlessedProperties(constructor))\n}\n\nfunction shadow<T>(constructor: Constructor<T>, properties: PropertyDescriptorMap) {\n  const shadowConstructor = extend(constructor)\n  const shadowProperties = getShadowProperties(constructor.prototype, properties)\n  Object.defineProperties(shadowConstructor.prototype, shadowProperties)\n  return shadowConstructor\n}\n\nfunction getBlessedProperties<T>(constructor: Constructor<T>) {\n  const blessings = readInheritableStaticArrayValues(constructor, \"blessings\") as Blessing<T>[]\n  return blessings.reduce((blessedProperties, blessing) => {\n    const properties = blessing(constructor)\n    for (const key in properties) {\n      const descriptor = blessedProperties[key] || ({} as PropertyDescriptor)\n      blessedProperties[key] = Object.assign(descriptor, properties[key])\n    }\n    return blessedProperties\n  }, {} as PropertyDescriptorMap)\n}\n\nfunction getShadowProperties(prototype: any, properties: PropertyDescriptorMap) {\n  return getOwnKeys(properties).reduce((shadowProperties, key) => {\n    const descriptor = getShadowedDescriptor(prototype, properties, key)\n    if (descriptor) {\n      Object.assign(shadowProperties, { [key]: descriptor })\n    }\n    return shadowProperties\n  }, {} as PropertyDescriptorMap)\n}\n\nfunction getShadowedDescriptor(prototype: any, properties: PropertyDescriptorMap, key: string | symbol) {\n  const shadowingDescriptor = Object.getOwnPropertyDescriptor(prototype, key)\n  const shadowedByValue = shadowingDescriptor && \"value\" in shadowingDescriptor\n  if (!shadowedByValue) {\n    const descriptor = Object.getOwnPropertyDescriptor(properties, key)!.value\n    if (shadowingDescriptor) {\n      descriptor.get = shadowingDescriptor.get || descriptor.get\n      descriptor.set = shadowingDescriptor.set || descriptor.set\n    }\n    return descriptor\n  }\n}\n\nconst getOwnKeys = (() => {\n  if (typeof Object.getOwnPropertySymbols == \"function\") {\n    return (object: any) => [...Object.getOwnPropertyNames(object), ...Object.getOwnPropertySymbols(object)]\n  } else {\n    return Object.getOwnPropertyNames\n  }\n})()\n\nconst extend = (() => {\n  function extendWithReflect<T extends Constructor<any>>(constructor: T): T {\n    function extended() {\n      return Reflect.construct(constructor, arguments, new.target)\n    }\n\n    extended.prototype = Object.create(constructor.prototype, {\n      constructor: { value: extended },\n    })\n\n    Reflect.setPrototypeOf(extended, constructor)\n    return extended as any\n  }\n\n  function testReflectExtension() {\n    const a = function (this: any) {\n      this.a.call(this)\n    } as any\n    const b = extendWithReflect(a)\n    b.prototype.a = function () {}\n    return new b()\n  }\n\n  try {\n    testReflectExtension()\n    return extendWithReflect\n  } catch (error: any) {\n    return <T extends Constructor<any>>(constructor: T) => class extended extends constructor {}\n  }\n})()\n","import { Application } from \"./application\"\nimport { Context } from \"./context\"\nimport { ControllerConstructor } from \"./controller\"\nimport { Definition, blessDefinition } from \"./definition\"\nimport { Scope } from \"./scope\"\n\nexport class Module {\n  readonly application: Application\n  readonly definition: Definition\n  private contextsByScope: WeakMap<Scope, Context>\n  private connectedContexts: Set<Context>\n\n  constructor(application: Application, definition: Definition) {\n    this.application = application\n    this.definition = blessDefinition(definition)\n    this.contextsByScope = new WeakMap()\n    this.connectedContexts = new Set()\n  }\n\n  get identifier(): string {\n    return this.definition.identifier\n  }\n\n  get controllerConstructor(): ControllerConstructor {\n    return this.definition.controllerConstructor\n  }\n\n  get contexts(): Context[] {\n    return Array.from(this.connectedContexts)\n  }\n\n  connectContextForScope(scope: Scope) {\n    const context = this.fetchContextForScope(scope)\n    this.connectedContexts.add(context)\n    context.connect()\n  }\n\n  disconnectContextForScope(scope: Scope) {\n    const context = this.contextsByScope.get(scope)\n    if (context) {\n      this.connectedContexts.delete(context)\n      context.disconnect()\n    }\n  }\n\n  private fetchContextForScope(scope: Scope): Context {\n    let context = this.contextsByScope.get(scope)\n    if (!context) {\n      context = new Context(this, scope)\n      this.contextsByScope.set(scope, context)\n    }\n    return context\n  }\n}\n","import { bless } from \"./blessing\"\nimport { ControllerConstructor } from \"./controller\"\n\nexport interface Definition {\n  identifier: string\n  controllerConstructor: ControllerConstructor\n}\n\nexport function blessDefinition(definition: Definition): Definition {\n  return {\n    identifier: definition.identifier,\n    controllerConstructor: bless(definition.controllerConstructor),\n  }\n}\n","import { Scope } from \"./scope\"\nimport { tokenize } from \"./string_helpers\"\n\nexport class ClassMap {\n  readonly scope: Scope\n\n  constructor(scope: Scope) {\n    this.scope = scope\n  }\n\n  has(name: string) {\n    return this.data.has(this.getDataKey(name))\n  }\n\n  get(name: string): string | undefined {\n    return this.getAll(name)[0]\n  }\n\n  getAll(name: string) {\n    const tokenString = this.data.get(this.getDataKey(name)) || \"\"\n    return tokenize(tokenString)\n  }\n\n  getAttributeName(name: string) {\n    return this.data.getAttributeNameForKey(this.getDataKey(name))\n  }\n\n  getDataKey(name: string) {\n    return `${name}-class`\n  }\n\n  get data() {\n    return this.scope.data\n  }\n}\n","import { Scope } from \"./scope\"\nimport { dasherize } from \"./string_helpers\"\n\nexport class DataMap {\n  readonly scope: Scope\n\n  constructor(scope: Scope) {\n    this.scope = scope\n  }\n\n  get element(): Element {\n    return this.scope.element\n  }\n\n  get identifier(): string {\n    return this.scope.identifier\n  }\n\n  get(key: string): string | null {\n    const name = this.getAttributeNameForKey(key)\n    return this.element.getAttribute(name)\n  }\n\n  set(key: string, value: string): string | null {\n    const name = this.getAttributeNameForKey(key)\n    this.element.setAttribute(name, value)\n    return this.get(key)\n  }\n\n  has(key: string): boolean {\n    const name = this.getAttributeNameForKey(key)\n    return this.element.hasAttribute(name)\n  }\n\n  delete(key: string): boolean {\n    if (this.has(key)) {\n      const name = this.getAttributeNameForKey(key)\n      this.element.removeAttribute(name)\n      return true\n    } else {\n      return false\n    }\n  }\n\n  getAttributeNameForKey(key: string): string {\n    return `data-${this.identifier}-${dasherize(key)}`\n  }\n}\n","import { Logger } from \"./logger\"\n\nexport class Guide {\n  readonly logger: Logger\n  readonly warnedKeysByObject: WeakMap<any, Set<string>> = new WeakMap()\n\n  constructor(logger: Logger) {\n    this.logger = logger\n  }\n\n  warn(object: any, key: string, message: string) {\n    let warnedKeys: Set<string> | undefined = this.warnedKeysByObject.get(object)\n\n    if (!warnedKeys) {\n      warnedKeys = new Set()\n      this.warnedKeysByObject.set(object, warnedKeys)\n    }\n\n    if (!warnedKeys.has(key)) {\n      warnedKeys.add(key)\n      this.logger.warn(message, object)\n    }\n  }\n}\n","export function attributeValueContainsToken(attributeName: string, token: string) {\n  return `[${attributeName}~=\"${token}\"]`\n}\n","import { Scope } from \"./scope\"\nimport { attributeValueContainsToken } from \"./selectors\"\n\nexport class TargetSet {\n  readonly scope: Scope\n\n  constructor(scope: Scope) {\n    this.scope = scope\n  }\n\n  get element() {\n    return this.scope.element\n  }\n\n  get identifier() {\n    return this.scope.identifier\n  }\n\n  get schema() {\n    return this.scope.schema\n  }\n\n  has(targetName: string) {\n    return this.find(targetName) != null\n  }\n\n  find(...targetNames: string[]) {\n    return targetNames.reduce(\n      (target, targetName) => target || this.findTarget(targetName) || this.findLegacyTarget(targetName),\n      undefined as Element | undefined\n    )\n  }\n\n  findAll(...targetNames: string[]) {\n    return targetNames.reduce(\n      (targets, targetName) => [\n        ...targets,\n        ...this.findAllTargets(targetName),\n        ...this.findAllLegacyTargets(targetName),\n      ],\n      [] as Element[]\n    )\n  }\n\n  private findTarget(targetName: string) {\n    const selector = this.getSelectorForTargetName(targetName)\n    return this.scope.findElement(selector)\n  }\n\n  private findAllTargets(targetName: string) {\n    const selector = this.getSelectorForTargetName(targetName)\n    return this.scope.findAllElements(selector)\n  }\n\n  private getSelectorForTargetName(targetName: string) {\n    const attributeName = this.schema.targetAttributeForScope(this.identifier)\n    return attributeValueContainsToken(attributeName, targetName)\n  }\n\n  private findLegacyTarget(targetName: string) {\n    const selector = this.getLegacySelectorForTargetName(targetName)\n    return this.deprecate(this.scope.findElement(selector), targetName)\n  }\n\n  private findAllLegacyTargets(targetName: string) {\n    const selector = this.getLegacySelectorForTargetName(targetName)\n    return this.scope.findAllElements(selector).map((element) => this.deprecate(element, targetName))\n  }\n\n  private getLegacySelectorForTargetName(targetName: string) {\n    const targetDescriptor = `${this.identifier}.${targetName}`\n    return attributeValueContainsToken(this.schema.targetAttribute, targetDescriptor)\n  }\n\n  private deprecate<T>(element: T, targetName: string) {\n    if (element) {\n      const { identifier } = this\n      const attributeName = this.schema.targetAttribute\n      const revisedAttributeName = this.schema.targetAttributeForScope(identifier)\n      this.guide.warn(\n        element,\n        `target:${targetName}`,\n        `Please replace ${attributeName}=\"${identifier}.${targetName}\" with ${revisedAttributeName}=\"${targetName}\". ` +\n          `The ${attributeName} attribute is deprecated and will be removed in a future version of Stimulus.`\n      )\n    }\n    return element\n  }\n\n  private get guide() {\n    return this.scope.guide\n  }\n}\n","import { ClassMap } from \"./class_map\"\nimport { DataMap } from \"./data_map\"\nimport { Guide } from \"./guide\"\nimport { Logger } from \"./logger\"\nimport { Schema } from \"./schema\"\nimport { attributeValueContainsToken } from \"./selectors\"\nimport { TargetSet } from \"./target_set\"\n\nexport class Scope {\n  readonly schema: Schema\n  readonly element: Element\n  readonly identifier: string\n  readonly guide: Guide\n  readonly targets = new TargetSet(this)\n  readonly classes = new ClassMap(this)\n  readonly data = new DataMap(this)\n\n  constructor(schema: Schema, element: Element, identifier: string, logger: Logger) {\n    this.schema = schema\n    this.element = element\n    this.identifier = identifier\n    this.guide = new Guide(logger)\n  }\n\n  findElement(selector: string): Element | undefined {\n    return this.element.matches(selector) ? this.element : this.queryElements(selector).find(this.containsElement)\n  }\n\n  findAllElements(selector: string): Element[] {\n    return [\n      ...(this.element.matches(selector) ? [this.element] : []),\n      ...this.queryElements(selector).filter(this.containsElement),\n    ]\n  }\n\n  containsElement = (element: Element): boolean => {\n    return element.closest(this.controllerSelector) === this.element\n  }\n\n  private queryElements(selector: string): Element[] {\n    return Array.from(this.element.querySelectorAll(selector))\n  }\n\n  private get controllerSelector(): string {\n    return attributeValueContainsToken(this.schema.controllerAttribute, this.identifier)\n  }\n}\n","import { ErrorHandler } from \"./error_handler\"\nimport { Schema } from \"./schema\"\nimport { Scope } from \"./scope\"\nimport { Token, ValueListObserver, ValueListObserverDelegate } from \"../mutation-observers\"\n\nexport interface ScopeObserverDelegate extends ErrorHandler {\n  createScopeForElementAndIdentifier(element: Element, identifier: string): Scope\n  scopeConnected(scope: Scope): void\n  scopeDisconnected(scope: Scope): void\n}\n\nexport class ScopeObserver implements ValueListObserverDelegate<Scope> {\n  readonly element: Element\n  readonly schema: Schema\n  private delegate: ScopeObserverDelegate\n  private valueListObserver: ValueListObserver<Scope>\n  private scopesByIdentifierByElement: WeakMap<Element, Map<string, Scope>>\n  private scopeReferenceCounts: WeakMap<Scope, number>\n\n  constructor(element: Element, schema: Schema, delegate: ScopeObserverDelegate) {\n    this.element = element\n    this.schema = schema\n    this.delegate = delegate\n    this.valueListObserver = new ValueListObserver(this.element, this.controllerAttribute, this)\n    this.scopesByIdentifierByElement = new WeakMap()\n    this.scopeReferenceCounts = new WeakMap()\n  }\n\n  start() {\n    this.valueListObserver.start()\n  }\n\n  stop() {\n    this.valueListObserver.stop()\n  }\n\n  get controllerAttribute() {\n    return this.schema.controllerAttribute\n  }\n\n  // Value observer delegate\n\n  parseValueForToken(token: Token): Scope | undefined {\n    const { element, content: identifier } = token\n    const scopesByIdentifier = this.fetchScopesByIdentifierForElement(element)\n\n    let scope = scopesByIdentifier.get(identifier)\n    if (!scope) {\n      scope = this.delegate.createScopeForElementAndIdentifier(element, identifier)\n      scopesByIdentifier.set(identifier, scope)\n    }\n\n    return scope\n  }\n\n  elementMatchedValue(element: Element, value: Scope) {\n    const referenceCount = (this.scopeReferenceCounts.get(value) || 0) + 1\n    this.scopeReferenceCounts.set(value, referenceCount)\n    if (referenceCount == 1) {\n      this.delegate.scopeConnected(value)\n    }\n  }\n\n  elementUnmatchedValue(element: Element, value: Scope) {\n    const referenceCount = this.scopeReferenceCounts.get(value)\n    if (referenceCount) {\n      this.scopeReferenceCounts.set(value, referenceCount - 1)\n      if (referenceCount == 1) {\n        this.delegate.scopeDisconnected(value)\n      }\n    }\n  }\n\n  private fetchScopesByIdentifierForElement(element: Element) {\n    let scopesByIdentifier = this.scopesByIdentifierByElement.get(element)\n    if (!scopesByIdentifier) {\n      scopesByIdentifier = new Map()\n      this.scopesByIdentifierByElement.set(element, scopesByIdentifier)\n    }\n    return scopesByIdentifier\n  }\n}\n","import { Application } from \"./application\"\nimport { Context } from \"./context\"\nimport { Definition } from \"./definition\"\nimport { Module } from \"./module\"\nimport { Multimap } from \"../multimap\"\nimport { Scope } from \"./scope\"\nimport { ScopeObserver, ScopeObserverDelegate } from \"./scope_observer\"\n\nexport class Router implements ScopeObserverDelegate {\n  readonly application: Application\n  private scopeObserver: ScopeObserver\n  private scopesByIdentifier: Multimap<string, Scope>\n  private modulesByIdentifier: Map<string, Module>\n\n  constructor(application: Application) {\n    this.application = application\n    this.scopeObserver = new ScopeObserver(this.element, this.schema, this)\n    this.scopesByIdentifier = new Multimap()\n    this.modulesByIdentifier = new Map()\n  }\n\n  get element() {\n    return this.application.element\n  }\n\n  get schema() {\n    return this.application.schema\n  }\n\n  get logger() {\n    return this.application.logger\n  }\n\n  get controllerAttribute(): string {\n    return this.schema.controllerAttribute\n  }\n\n  get modules() {\n    return Array.from(this.modulesByIdentifier.values())\n  }\n\n  get contexts() {\n    return this.modules.reduce((contexts, module) => contexts.concat(module.contexts), [] as Context[])\n  }\n\n  start() {\n    this.scopeObserver.start()\n  }\n\n  stop() {\n    this.scopeObserver.stop()\n  }\n\n  loadDefinition(definition: Definition) {\n    this.unloadIdentifier(definition.identifier)\n    const module = new Module(this.application, definition)\n    this.connectModule(module)\n  }\n\n  unloadIdentifier(identifier: string) {\n    const module = this.modulesByIdentifier.get(identifier)\n    if (module) {\n      this.disconnectModule(module)\n    }\n  }\n\n  getContextForElementAndIdentifier(element: Element, identifier: string) {\n    const module = this.modulesByIdentifier.get(identifier)\n    if (module) {\n      return module.contexts.find((context) => context.element == element)\n    }\n  }\n\n  // Error handler delegate\n\n  handleError(error: Error, message: string, detail: any) {\n    this.application.handleError(error, message, detail)\n  }\n\n  // Scope observer delegate\n\n  createScopeForElementAndIdentifier(element: Element, identifier: string) {\n    return new Scope(this.schema, element, identifier, this.logger)\n  }\n\n  scopeConnected(scope: Scope) {\n    this.scopesByIdentifier.add(scope.identifier, scope)\n    const module = this.modulesByIdentifier.get(scope.identifier)\n    if (module) {\n      module.connectContextForScope(scope)\n    }\n  }\n\n  scopeDisconnected(scope: Scope) {\n    this.scopesByIdentifier.delete(scope.identifier, scope)\n    const module = this.modulesByIdentifier.get(scope.identifier)\n    if (module) {\n      module.disconnectContextForScope(scope)\n    }\n  }\n\n  // Modules\n\n  private connectModule(module: Module) {\n    this.modulesByIdentifier.set(module.identifier, module)\n    const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier)\n    scopes.forEach((scope) => module.connectContextForScope(scope))\n  }\n\n  private disconnectModule(module: Module) {\n    this.modulesByIdentifier.delete(module.identifier)\n    const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier)\n    scopes.forEach((scope) => module.disconnectContextForScope(scope))\n  }\n}\n","export interface Schema {\n  controllerAttribute: string\n  actionAttribute: string\n  targetAttribute: string\n  targetAttributeForScope(identifier: string): string\n}\n\nexport const defaultSchema: Schema = {\n  controllerAttribute: \"data-controller\",\n  actionAttribute: \"data-action\",\n  targetAttribute: \"data-target\",\n  targetAttributeForScope: (identifier) => `data-${identifier}-target`,\n}\n","import { Controller, ControllerConstructor } from \"./controller\"\nimport { Definition } from \"./definition\"\nimport { Dispatcher } from \"./dispatcher\"\nimport { ErrorHandler } from \"./error_handler\"\nimport { Logger } from \"./logger\"\nimport { Router } from \"./router\"\nimport { Schema, defaultSchema } from \"./schema\"\nimport { ActionDescriptorFilter, ActionDescriptorFilters, defaultActionDescriptorFilters } from \"./action_descriptor\"\n\nexport class Application implements ErrorHandler {\n  readonly element: Element\n  readonly schema: Schema\n  readonly dispatcher: Dispatcher\n  readonly router: Router\n  readonly actionDescriptorFilters: ActionDescriptorFilters\n  logger: Logger = console\n  debug = false\n\n  static start(element?: Element, schema?: Schema): Application {\n    const application = new Application(element, schema)\n    application.start()\n    return application\n  }\n\n  constructor(element: Element = document.documentElement, schema: Schema = defaultSchema) {\n    this.element = element\n    this.schema = schema\n    this.dispatcher = new Dispatcher(this)\n    this.router = new Router(this)\n    this.actionDescriptorFilters = { ...defaultActionDescriptorFilters }\n  }\n\n  async start() {\n    await domReady()\n    this.logDebugActivity(\"application\", \"starting\")\n    this.dispatcher.start()\n    this.router.start()\n    this.logDebugActivity(\"application\", \"start\")\n  }\n\n  stop() {\n    this.logDebugActivity(\"application\", \"stopping\")\n    this.dispatcher.stop()\n    this.router.stop()\n    this.logDebugActivity(\"application\", \"stop\")\n  }\n\n  register(identifier: string, controllerConstructor: ControllerConstructor) {\n    this.load({ identifier, controllerConstructor })\n  }\n\n  registerActionOption(name: string, filter: ActionDescriptorFilter) {\n    this.actionDescriptorFilters[name] = filter\n  }\n\n  load(...definitions: Definition[]): void\n  load(definitions: Definition[]): void\n  load(head: Definition | Definition[], ...rest: Definition[]) {\n    const definitions = Array.isArray(head) ? head : [head, ...rest]\n    definitions.forEach((definition) => {\n      if ((definition.controllerConstructor as any).shouldLoad) {\n        this.router.loadDefinition(definition)\n      }\n    })\n  }\n\n  unload(...identifiers: string[]): void\n  unload(identifiers: string[]): void\n  unload(head: string | string[], ...rest: string[]) {\n    const identifiers = Array.isArray(head) ? head : [head, ...rest]\n    identifiers.forEach((identifier) => this.router.unloadIdentifier(identifier))\n  }\n\n  // Controllers\n\n  get controllers(): Controller[] {\n    return this.router.contexts.map((context) => context.controller)\n  }\n\n  getControllerForElementAndIdentifier(element: Element, identifier: string): Controller | null {\n    const context = this.router.getContextForElementAndIdentifier(element, identifier)\n    return context ? context.controller : null\n  }\n\n  // Error handling\n\n  handleError(error: Error, message: string, detail: object) {\n    this.logger.error(`%s\\n\\n%o\\n\\n%o`, message, error, detail)\n\n    window.onerror?.(message, \"\", 0, 0, error)\n  }\n\n  // Debug logging\n\n  logDebugActivity = (identifier: string, functionName: string, detail: object = {}): void => {\n    if (this.debug) {\n      this.logFormattedMessage(identifier, functionName, detail)\n    }\n  }\n\n  private logFormattedMessage(identifier: string, functionName: string, detail: object = {}) {\n    detail = Object.assign({ application: this }, detail)\n\n    this.logger.groupCollapsed(`${identifier} #${functionName}`)\n    this.logger.log(\"details:\", { ...detail })\n    this.logger.groupEnd()\n  }\n}\n\nfunction domReady() {\n  return new Promise<void>((resolve) => {\n    if (document.readyState == \"loading\") {\n      document.addEventListener(\"DOMContentLoaded\", () => resolve())\n    } else {\n      resolve()\n    }\n  })\n}\n","import { Constructor } from \"./constructor\"\nimport { Controller } from \"./controller\"\nimport { readInheritableStaticObjectPairs } from \"./inheritable_statics\"\nimport { camelize, capitalize, dasherize } from \"./string_helpers\"\n\nexport function ValuePropertiesBlessing<T>(constructor: Constructor<T>) {\n  const valueDefinitionPairs = readInheritableStaticObjectPairs<T, ValueTypeDefinition>(constructor, \"values\")\n  const propertyDescriptorMap: PropertyDescriptorMap = {\n    valueDescriptorMap: {\n      get(this: Controller) {\n        return valueDefinitionPairs.reduce((result, valueDefinitionPair) => {\n          const valueDescriptor = parseValueDefinitionPair(valueDefinitionPair, this.identifier)\n          const attributeName = this.data.getAttributeNameForKey(valueDescriptor.key)\n          return Object.assign(result, { [attributeName]: valueDescriptor })\n        }, {} as ValueDescriptorMap)\n      },\n    },\n  }\n\n  return valueDefinitionPairs.reduce((properties, valueDefinitionPair) => {\n    return Object.assign(properties, propertiesForValueDefinitionPair(valueDefinitionPair))\n  }, propertyDescriptorMap)\n}\n\nexport function propertiesForValueDefinitionPair<T>(\n  valueDefinitionPair: ValueDefinitionPair,\n  controller?: string\n): PropertyDescriptorMap {\n  const definition = parseValueDefinitionPair(valueDefinitionPair, controller)\n  const { key, name, reader: read, writer: write } = definition\n\n  return {\n    [name]: {\n      get(this: Controller) {\n        const value = this.data.get(key)\n        if (value !== null) {\n          return read(value)\n        } else {\n          return definition.defaultValue\n        }\n      },\n\n      set(this: Controller, value: T | undefined) {\n        if (value === undefined) {\n          this.data.delete(key)\n        } else {\n          this.data.set(key, write(value))\n        }\n      },\n    },\n\n    [`has${capitalize(name)}`]: {\n      get(this: Controller): boolean {\n        return this.data.has(key) || definition.hasCustomDefaultValue\n      },\n    },\n  }\n}\n\nexport type ValueDescriptor = {\n  type: ValueType\n  key: string\n  name: string\n  defaultValue: ValueTypeDefault\n  hasCustomDefaultValue: boolean\n  reader: Reader\n  writer: Writer\n}\n\nexport type ValueDescriptorMap = { [attributeName: string]: ValueDescriptor }\n\nexport type ValueDefinitionMap = { [token: string]: ValueTypeDefinition }\n\nexport type ValueDefinitionPair = [string, ValueTypeDefinition]\n\nexport type ValueTypeConstant = typeof Array | typeof Boolean | typeof Number | typeof Object | typeof String\n\nexport type ValueTypeDefault = Array<any> | boolean | number | Object | string\n\nexport type ValueTypeObject = { type: ValueTypeConstant; default: ValueTypeDefault }\n\nexport type ValueTypeDefinition = ValueTypeConstant | ValueTypeDefault | ValueTypeObject\n\nexport type ValueType = \"array\" | \"boolean\" | \"number\" | \"object\" | \"string\"\n\nfunction parseValueDefinitionPair([token, typeDefinition]: ValueDefinitionPair, controller?: string): ValueDescriptor {\n  return valueDescriptorForTokenAndTypeDefinition({\n    controller,\n    token,\n    typeDefinition,\n  })\n}\n\nfunction parseValueTypeConstant(constant: ValueTypeConstant) {\n  switch (constant) {\n    case Array:\n      return \"array\"\n    case Boolean:\n      return \"boolean\"\n    case Number:\n      return \"number\"\n    case Object:\n      return \"object\"\n    case String:\n      return \"string\"\n  }\n}\n\nfunction parseValueTypeDefault(defaultValue: ValueTypeDefault) {\n  switch (typeof defaultValue) {\n    case \"boolean\":\n      return \"boolean\"\n    case \"number\":\n      return \"number\"\n    case \"string\":\n      return \"string\"\n  }\n\n  if (Array.isArray(defaultValue)) return \"array\"\n  if (Object.prototype.toString.call(defaultValue) === \"[object Object]\") return \"object\"\n}\n\nfunction parseValueTypeObject(payload: { controller?: string; token: string; typeObject: ValueTypeObject }) {\n  const typeFromObject = parseValueTypeConstant(payload.typeObject.type)\n\n  if (!typeFromObject) return\n\n  const defaultValueType = parseValueTypeDefault(payload.typeObject.default)\n\n  if (typeFromObject !== defaultValueType) {\n    const propertyPath = payload.controller ? `${payload.controller}.${payload.token}` : payload.token\n\n    throw new Error(\n      `The specified default value for the Stimulus Value \"${propertyPath}\" must match the defined type \"${typeFromObject}\". The provided default value of \"${payload.typeObject.default}\" is of type \"${defaultValueType}\".`\n    )\n  }\n\n  return typeFromObject\n}\n\nfunction parseValueTypeDefinition(payload: {\n  controller?: string\n  token: string\n  typeDefinition: ValueTypeDefinition\n}): ValueType {\n  const typeFromObject = parseValueTypeObject({\n    controller: payload.controller,\n    token: payload.token,\n    typeObject: payload.typeDefinition as ValueTypeObject,\n  })\n  const typeFromDefaultValue = parseValueTypeDefault(payload.typeDefinition as ValueTypeDefault)\n  const typeFromConstant = parseValueTypeConstant(payload.typeDefinition as ValueTypeConstant)\n\n  const type = typeFromObject || typeFromDefaultValue || typeFromConstant\n\n  if (type) return type\n\n  const propertyPath = payload.controller ? `${payload.controller}.${payload.typeDefinition}` : payload.token\n\n  throw new Error(`Unknown value type \"${propertyPath}\" for \"${payload.token}\" value`)\n}\n\nfunction defaultValueForDefinition(typeDefinition: ValueTypeDefinition): ValueTypeDefault {\n  const constant = parseValueTypeConstant(typeDefinition as ValueTypeConstant)\n\n  if (constant) return defaultValuesByType[constant]\n\n  const defaultValue = (typeDefinition as ValueTypeObject).default\n  if (defaultValue !== undefined) return defaultValue\n\n  return typeDefinition\n}\n\nfunction valueDescriptorForTokenAndTypeDefinition(payload: {\n  token: string\n  typeDefinition: ValueTypeDefinition\n  controller?: string\n}) {\n  const key = `${dasherize(payload.token)}-value`\n  const type = parseValueTypeDefinition(payload)\n  return {\n    type,\n    key,\n    name: camelize(key),\n    get defaultValue() {\n      return defaultValueForDefinition(payload.typeDefinition)\n    },\n    get hasCustomDefaultValue() {\n      return parseValueTypeDefault(payload.typeDefinition) !== undefined\n    },\n    reader: readers[type],\n    writer: writers[type] || writers.default,\n  }\n}\n\nconst defaultValuesByType = {\n  get array() {\n    return []\n  },\n  boolean: false,\n  number: 0,\n  get object() {\n    return {}\n  },\n  string: \"\",\n}\n\ntype Reader = (value: string) => any\n\nconst readers: { [type: string]: Reader } = {\n  array(value: string): any[] {\n    const array = JSON.parse(value)\n    if (!Array.isArray(array)) {\n      throw new TypeError(\n        `expected value of type \"array\" but instead got value \"${value}\" of type \"${parseValueTypeDefault(array)}\"`\n      )\n    }\n    return array\n  },\n\n  boolean(value: string): boolean {\n    return !(value == \"0\" || String(value).toLowerCase() == \"false\")\n  },\n\n  number(value: string): number {\n    return Number(value)\n  },\n\n  object(value: string): object {\n    const object = JSON.parse(value)\n    if (object === null || typeof object != \"object\" || Array.isArray(object)) {\n      throw new TypeError(\n        `expected value of type \"object\" but instead got value \"${value}\" of type \"${parseValueTypeDefault(object)}\"`\n      )\n    }\n    return object\n  },\n\n  string(value: string): string {\n    return value\n  },\n}\n\ntype Writer = (value: any) => string\n\nconst writers: { [type: string]: Writer } = {\n  default: writeString,\n  array: writeJSON,\n  object: writeJSON,\n}\n\nfunction writeJSON(value: any) {\n  return JSON.stringify(value)\n}\n\nfunction writeString(value: any) {\n  return `${value}`\n}\n","import { ClassPropertiesBlessing } from \"./class_properties\"\nimport { Constructor } from \"./constructor\"\nimport { Context } from \"./context\"\nimport { TargetPropertiesBlessing } from \"./target_properties\"\nimport { ValuePropertiesBlessing, ValueDefinitionMap } from \"./value_properties\"\n\nexport type ControllerConstructor = Constructor<Controller>\n\nexport class Controller<ElementType extends Element = Element> {\n  static blessings = [ClassPropertiesBlessing, TargetPropertiesBlessing, ValuePropertiesBlessing]\n  static targets: string[] = []\n  static values: ValueDefinitionMap = {}\n\n  static get shouldLoad() {\n    return true\n  }\n\n  readonly context: Context\n\n  constructor(context: Context) {\n    this.context = context\n  }\n\n  get application() {\n    return this.context.application\n  }\n\n  get scope() {\n    return this.context.scope\n  }\n\n  get element() {\n    return this.scope.element as ElementType\n  }\n\n  get identifier() {\n    return this.scope.identifier\n  }\n\n  get targets() {\n    return this.scope.targets\n  }\n\n  get classes() {\n    return this.scope.classes\n  }\n\n  get data() {\n    return this.scope.data\n  }\n\n  initialize() {\n    // Override in your subclass to set up initial controller state\n  }\n\n  connect() {\n    // Override in your subclass to respond when the controller is connected to the DOM\n  }\n\n  disconnect() {\n    // Override in your subclass to respond when the controller is disconnected from the DOM\n  }\n\n  dispatch(\n    eventName: string,\n    { target = this.element, detail = {}, prefix = this.identifier, bubbles = true, cancelable = true } = {}\n  ) {\n    const type = prefix ? `${prefix}:${eventName}` : eventName\n    const event = new CustomEvent(type, { detail, bubbles, cancelable })\n    target.dispatchEvent(event)\n    return event\n  }\n}\n","import { Constructor } from \"./constructor\"\nimport { Controller } from \"./controller\"\nimport { readInheritableStaticArrayValues } from \"./inheritable_statics\"\nimport { capitalize } from \"./string_helpers\"\n\nexport function ClassPropertiesBlessing<T>(constructor: Constructor<T>) {\n  const classes = readInheritableStaticArrayValues(constructor, \"classes\")\n  return classes.reduce((properties, classDefinition) => {\n    return Object.assign(properties, propertiesForClassDefinition(classDefinition))\n  }, {} as PropertyDescriptorMap)\n}\n\nfunction propertiesForClassDefinition(key: string) {\n  return {\n    [`${key}Class`]: {\n      get(this: Controller) {\n        const { classes } = this\n        if (classes.has(key)) {\n          return classes.get(key)\n        } else {\n          const attribute = classes.getAttributeName(key)\n          throw new Error(`Missing attribute \"${attribute}\"`)\n        }\n      },\n    },\n\n    [`${key}Classes`]: {\n      get(this: Controller) {\n        return this.classes.getAll(key)\n      },\n    },\n\n    [`has${capitalize(key)}Class`]: {\n      get(this: Controller) {\n        return this.classes.has(key)\n      },\n    },\n  }\n}\n","import { Constructor } from \"./constructor\"\nimport { Controller } from \"./controller\"\nimport { readInheritableStaticArrayValues } from \"./inheritable_statics\"\nimport { capitalize } from \"./string_helpers\"\n\nexport function TargetPropertiesBlessing<T>(constructor: Constructor<T>) {\n  const targets = readInheritableStaticArrayValues(constructor, \"targets\")\n  return targets.reduce((properties, targetDefinition) => {\n    return Object.assign(properties, propertiesForTargetDefinition(targetDefinition))\n  }, {} as PropertyDescriptorMap)\n}\n\nfunction propertiesForTargetDefinition(name: string) {\n  return {\n    [`${name}Target`]: {\n      get(this: Controller) {\n        const target = this.targets.find(name)\n        if (target) {\n          return target\n        } else {\n          throw new Error(`Missing target element \"${name}\" for \"${this.identifier}\" controller`)\n        }\n      },\n    },\n\n    [`${name}Targets`]: {\n      get(this: Controller) {\n        return this.targets.findAll(name)\n      },\n    },\n\n    [`has${capitalize(name)}Target`]: {\n      get(this: Controller) {\n        return this.targets.has(name)\n      },\n    },\n  }\n}\n"],"names":["EventListener","constructor","eventTarget","eventName","eventOptions","this","unorderedBindings","Set","connect","addEventListener","disconnect","removeEventListener","bindingConnected","binding","add","bindingDisconnected","delete","handleEvent","event","extendedEvent","stopImmediatePropagation","Object","assign","immediatePropagationStopped","call","extendEvent","bindings","hasBindings","size","Array","from","sort","left","right","leftIndex","index","rightIndex","Dispatcher","application","eventListenerMaps","Map","started","start","eventListeners","forEach","eventListener","stop","values","reduce","listeners","map","concat","fetchEventListenerForBinding","clearEventListeners","clearEventListenersForBinding","handleError","error","message","detail","removeMappedEventListenerFor","eventListenerMap","fetchEventListenerMapForEventTarget","cacheKey","fetchEventListener","get","createEventListener","set","parts","keys","key","push","join","defaultActionDescriptorFilters","value","stopPropagation","prevent","preventDefault","self","element","target","descriptorPattern","parseEventTarget","eventTargetName","window","document","camelize","replace","_","char","toUpperCase","capitalize","charAt","slice","dasherize","toLowerCase","defaultEventNames","a","button","form","details","input","e","getAttribute","select","textarea","Error","typecast","JSON","parse","o_O","Binding","context","action","identifier","willBeInvokedByEvent","applyEventModifiers","invokeWithEvent","method","controller","methodName","actionDescriptorFilters","passes","name","entries","filter","currentTarget","params","actionEvent","logDebugActivity","Element","contains","scope","containsElement","ElementObserver","delegate","attributes","childList","subtree","elements","mutationObserver","MutationObserver","mutations","processMutations","observe","mutationObserverInit","refresh","pause","callback","takeRecords","matches","matchElementsInTree","has","removeElement","addElement","mutation","processMutation","type","processAttributeChange","attributeName","processRemovedNodes","removedNodes","processAddedNodes","addedNodes","node","elementAttributeChanged","matchElement","nodes","elementFromNode","processTree","elementIsActive","tree","processor","nodeType","Node","ELEMENT_NODE","isConnected","elementMatched","elementUnmatched","AttributeObserver","elementObserver","selector","hasAttribute","match","querySelectorAll","elementMatchedAttribute","elementUnmatchedAttribute","elementAttributeValueChanged","StringMapObserver","stringMap","attributeOldValue","knownAttributeNames","refreshAttribute","oldValue","getStringMapKeyForAttribute","stringMapKeyAdded","stringMapValueChanged","stringMapKeyRemoved","currentAttributeNames","recordedAttributeNames","attribute","fetch","del","prune","Multimap","valuesByKey","hasKey","hasValue","some","getValuesForKey","getKeysForValue","_key","_values","IndexedMultimap","super","keysByValue","TokenListObserver","attributeObserver","tokensByElement","tokensMatched","readTokensForElement","unmatchedTokens","matchedTokens","refreshTokensForElement","tokensUnmatched","tokens","token","tokenMatched","tokenUnmatched","previousTokens","currentTokens","firstDifferingIndex","length","Math","max","zip","findIndex","previousToken","currentToken","content","tokenString","trim","split","parseTokenString","ValueListObserver","tokenListObserver","parseResultsByToken","WeakMap","valuesByTokenByElement","fetchParseResultForToken","fetchValuesByTokenForElement","elementMatchedValue","elementUnmatchedValue","parseResult","parseToken","valuesByToken","parseValueForToken","BindingObserver","bindingsByAction","valueListObserver","actionAttribute","disconnectAllActions","schema","connectAction","disconnectAction","clear","descriptor","tagName","getDefaultEventNameForElement","forToken","descriptorString","options","test","parseActionDescriptorString","toString","eventNameSuffix","pattern","RegExp","ValueObserver","receiver","stringMapObserver","valueDescriptorMap","invokeChangedCallbacksForDefaultValues","invokeChangedCallback","writer","defaultValue","valueDescriptorNameMap","valueDescriptors","undefined","data","rawValue","rawOldValue","changedMethodName","changedMethod","reader","TypeError","descriptors","hasMethodName","TargetObserver","targetsByName","disconnectAllTargets","connectTarget","disconnectTarget","targetConnected","targetDisconnected","Context","module","functionName","controllerConstructor","bindingObserver","dispatcher","valueObserver","targetObserver","initialize","parentElement","invokeControllerMethod","args","readInheritableStaticArrayValues","propertyName","ancestors","getAncestorsForConstructor","definition","isArray","getOwnStaticArrayValues","readInheritableStaticObjectPairs","pairs","getOwnStaticObjectPairs","getPrototypeOf","reverse","bless","properties","shadowConstructor","extend","shadowProperties","prototype","getOwnKeys","shadowingDescriptor","getOwnPropertyDescriptor","getShadowedDescriptor","getShadowProperties","defineProperties","shadow","blessedProperties","blessing","getBlessedProperties","getOwnPropertySymbols","object","getOwnPropertyNames","extendWithReflect","extended","Reflect","construct","arguments","create","setPrototypeOf","b","testReflectExtension","Module","blessDefinition","contextsByScope","connectedContexts","contexts","connectContextForScope","fetchContextForScope","disconnectContextForScope","ClassMap","getDataKey","getAll","getAttributeName","getAttributeNameForKey","DataMap","setAttribute","removeAttribute","Guide","logger","warn","warnedKeys","warnedKeysByObject","attributeValueContainsToken","TargetSet","targetName","find","targetNames","findTarget","findLegacyTarget","findAll","targets","findAllTargets","findAllLegacyTargets","getSelectorForTargetName","findElement","findAllElements","targetAttributeForScope","getLegacySelectorForTargetName","deprecate","targetDescriptor","targetAttribute","revisedAttributeName","guide","Scope","closest","controllerSelector","queryElements","controllerAttribute","ScopeObserver","scopesByIdentifierByElement","scopeReferenceCounts","scopesByIdentifier","fetchScopesByIdentifierForElement","createScopeForElementAndIdentifier","referenceCount","scopeConnected","scopeDisconnected","Router","scopeObserver","modulesByIdentifier","modules","loadDefinition","unloadIdentifier","connectModule","disconnectModule","getContextForElementAndIdentifier","defaultSchema","Application","documentElement","console","debug","logFormattedMessage","router","Promise","resolve","readyState","register","load","registerActionOption","head","rest","shouldLoad","unload","controllers","getControllerForElementAndIdentifier","onerror","groupCollapsed","log","groupEnd","parseValueDefinitionPair","typeDefinition","payload","typeFromObject","parseValueTypeConstant","typeObject","defaultValueType","parseValueTypeDefault","default","propertyPath","parseValueTypeObject","typeFromDefaultValue","typeFromConstant","parseValueTypeDefinition","constant","defaultValuesByType","defaultValueForDefinition","hasCustomDefaultValue","readers","writers","valueDescriptorForTokenAndTypeDefinition","Boolean","Number","String","array","boolean","number","string","writeJSON","stringify","Controller","classes","dispatch","prefix","bubbles","cancelable","CustomEvent","dispatchEvent","classDefinition","targetDefinition","valueDefinitionPairs","propertyDescriptorMap","result","valueDefinitionPair","valueDescriptor","read","write","propertiesForValueDefinitionPair"],"mappings":"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"}